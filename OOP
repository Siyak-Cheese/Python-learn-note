**** Tutorial 1: Classes and Instances ****
> class Example:
> __init__(self,)
    # Initializes the parameters and instances of the class.
    # self is instance equal to variable.
    # var_1 = Example()
    # var_1 is self.
> def method(self):
    # self is instance of method.
> Example.method(self=variable)
    # assgin variable as self(instance)
    # let calss method know what does instance.
> exma_1.method()
    # exma_1 = self in method.

**** Tutorial 2: Classes Variables ****
> Share class variable in all instances of class.
> __dict__: namespace
> self.
> class.

**** Tutorial 3: classmethods and staticmethods ****
> @classmethod
> @staticmethod

**** Decorators - Dynamically Alter The Functionality Of Your Functions ****

**** Closures - How to Use Them and Why They Are Useful ****
> function is object pass to variable.
> variable could be a method.
> recap: Closures allow us to take advantage of first-class functions and return an
            inner function that remember and has access to variables local to the scope in which they were created. 

**** First-Class Functions ****
>>> def First_func(x):

        def Second_func(y):
            print(f"<{x}><{y}><{x}>")

        return Second_func
    
    msg_h1 = First_func('h1') # msg is equal to Second_func(function). 'h1' pass to x.
    msg_h1('Test headline') # 'Test sencond function' pass to y.
    msg_h1('Test other headline') # 'Test other headline' pass to y.

    msg_p = First_func('p')
    msg_p('Test Paragraph!')
>>>
> recap: First function allow us to treat functions like any other object.
    # Tips: We can pass functions as arguments to another functions.
            We can return functions.
            We can assign functions to Variables.